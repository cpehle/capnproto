-- Generated by capnpc-lean4; DO NOT EDIT.
-- source: test/lean4/fixtures/rpc_echo.capnp

import Capnp.Runtime
import Capnp.Rpc

set_option maxHeartbeats 2000000


namespace Capnp.Gen.test.lean4.fixtures.rpc_echo

structure Echo.foo_Params.Reader where
  struct : Capnp.StructReader

  deriving BEq

def Echo.foo_Params.read (ptr : Capnp.AnyPointer) : Echo.foo_Params.Reader := { struct := Capnp.readStruct ptr }
def Echo.foo_Params.readChecked (ptr : Capnp.AnyPointer) : Except String Echo.foo_Params.Reader := do
  let sr ← Capnp.readStructChecked ptr
  return { struct := sr }
def Echo.foo_Params.fromStruct (sr : Capnp.StructReader) : Echo.foo_Params.Reader := { struct := sr }

structure Echo.foo_Params.Builder where
  struct : Capnp.StructBuilder

  deriving BEq

def Echo.foo_Params.Builder.fromStruct (sb : Capnp.StructBuilder) : Echo.foo_Params.Builder := { struct := sb }


structure Echo.foo_Results.Reader where
  struct : Capnp.StructReader

  deriving BEq

def Echo.foo_Results.read (ptr : Capnp.AnyPointer) : Echo.foo_Results.Reader := { struct := Capnp.readStruct ptr }
def Echo.foo_Results.readChecked (ptr : Capnp.AnyPointer) : Except String Echo.foo_Results.Reader := do
  let sr ← Capnp.readStructChecked ptr
  return { struct := sr }
def Echo.foo_Results.fromStruct (sr : Capnp.StructReader) : Echo.foo_Results.Reader := { struct := sr }

structure Echo.foo_Results.Builder where
  struct : Capnp.StructBuilder

  deriving BEq

def Echo.foo_Results.Builder.fromStruct (sb : Capnp.StructBuilder) : Echo.foo_Results.Builder := { struct := sb }


structure Echo.bar_Params.Reader where
  struct : Capnp.StructReader

  deriving BEq

def Echo.bar_Params.read (ptr : Capnp.AnyPointer) : Echo.bar_Params.Reader := { struct := Capnp.readStruct ptr }
def Echo.bar_Params.readChecked (ptr : Capnp.AnyPointer) : Except String Echo.bar_Params.Reader := do
  let sr ← Capnp.readStructChecked ptr
  return { struct := sr }
def Echo.bar_Params.fromStruct (sr : Capnp.StructReader) : Echo.bar_Params.Reader := { struct := sr }

structure Echo.bar_Params.Builder where
  struct : Capnp.StructBuilder

  deriving BEq

def Echo.bar_Params.Builder.fromStruct (sb : Capnp.StructBuilder) : Echo.bar_Params.Builder := { struct := sb }


structure Echo.bar_Results.Reader where
  struct : Capnp.StructReader

  deriving BEq

def Echo.bar_Results.read (ptr : Capnp.AnyPointer) : Echo.bar_Results.Reader := { struct := Capnp.readStruct ptr }
def Echo.bar_Results.readChecked (ptr : Capnp.AnyPointer) : Except String Echo.bar_Results.Reader := do
  let sr ← Capnp.readStructChecked ptr
  return { struct := sr }
def Echo.bar_Results.fromStruct (sr : Capnp.StructReader) : Echo.bar_Results.Reader := { struct := sr }

structure Echo.bar_Results.Builder where
  struct : Capnp.StructBuilder

  deriving BEq

def Echo.bar_Results.Builder.fromStruct (sb : Capnp.StructBuilder) : Echo.bar_Results.Builder := { struct := sb }


abbrev Echo := Capnp.Rpc.Client

namespace Echo

def interfaceId : UInt64 := UInt64.ofNat 17981429201013962691

def fooMethodId : UInt16 := UInt16.ofNat 0
def fooMethod : Capnp.Rpc.Method := { interfaceId := interfaceId, methodId := fooMethodId }
def callFoo (backend : Capnp.Rpc.Backend) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO Capnp.Rpc.Payload := do
  Capnp.Rpc.call backend target fooMethod payload
def callFooM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.Payload := do
  Capnp.Rpc.RuntimeM.call target fooMethod payload
def startFoo (runtime : Capnp.Rpc.Runtime) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO Capnp.Rpc.RuntimePendingCallRef := do
  Capnp.Rpc.Runtime.startCall runtime target fooMethod payload
def startFooM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.RuntimePendingCallRef := do
  Capnp.Rpc.RuntimeM.startCall target fooMethod payload
def awaitFoo (pendingCall : Capnp.Rpc.RuntimePendingCallRef) : IO Capnp.Rpc.Payload := do
  pendingCall.await
abbrev FooResponse := Capnp.Rpc.TypedPayload Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.foo_Results.Reader
abbrev FooPromise := Capnp.Rpc.Promise FooResponse
def startFooPromise (runtime : Capnp.Rpc.Runtime) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO FooPromise := do
  return { pendingCall := (← startFoo runtime target payload) }
def startFooPromiseM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM FooPromise := do
  return { pendingCall := (← startFooM target payload) }
def FooPromise.await (promise : FooPromise) : IO Capnp.Rpc.Payload := do
  awaitFoo promise.pendingCall
def FooPromise.release (promise : FooPromise) : IO Unit :=
  promise.pendingCall.release
def FooPromise.releaseDeferred (promise : FooPromise) : IO Unit :=
  promise.pendingCall.releaseDeferred
abbrev fooTypedHandler := Capnp.Rpc.Client -> Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.foo_Params.Reader -> Capnp.CapTable -> IO Capnp.Rpc.Payload
abbrev fooAdvancedTypedHandler := Capnp.Rpc.Client -> Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.foo_Params.Reader -> Capnp.CapTable -> IO Capnp.Rpc.AdvancedHandlerReply
abbrev fooStreamingTypedHandler := Capnp.Rpc.Client -> Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.foo_Params.Reader -> Capnp.CapTable -> IO Capnp.Rpc.AdvancedHandlerReply
def fooRequestOfPayload (payload : Capnp.Rpc.Payload) : IO (Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.foo_Params.Reader × Capnp.CapTable) := do
  let reader ← match Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.foo_Params.readChecked (Capnp.getRoot payload.msg) with
    | Except.ok r => pure r
    | Except.error e => throw (IO.userError s!"invalid fooMethod request: {e}")
  return (reader, payload.capTable)
def fooResponseOfPayload (payload : Capnp.Rpc.Payload) : IO FooResponse := do
  let reader ← match Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.foo_Results.readChecked (Capnp.getRoot payload.msg) with
    | Except.ok r => pure r
    | Except.error e => throw (IO.userError s!"invalid fooMethod response: {e}")
  return { reader := reader, capTable := payload.capTable }
def callFooTyped (backend : Capnp.Rpc.Backend) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO FooResponse := do
  let response ← Capnp.Rpc.call backend target fooMethod payload
  fooResponseOfPayload response
def callFooTypedM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM FooResponse := do
  let response ← Capnp.Rpc.RuntimeM.call target fooMethod payload
  fooResponseOfPayload response
def awaitFooTyped (pendingCall : Capnp.Rpc.RuntimePendingCallRef) : IO FooResponse := do
  let response ← pendingCall.await
  fooResponseOfPayload response
def FooPromise.awaitTyped (promise : FooPromise) : IO FooResponse := do
  awaitFooTyped promise.pendingCall
def FooPromise.awaitAndRelease (promise : FooPromise) : IO Capnp.Rpc.Payload := do
  promise.pendingCall.awaitAndRelease
def FooPromise.awaitTypedAndRelease (promise : FooPromise) : IO FooResponse := do
  let response ← promise.pendingCall.awaitAndRelease
  fooResponseOfPayload response
def getFooPipelinedCap (pendingCall : Capnp.Rpc.RuntimePendingCallRef)
    (pointerPath : Array UInt16 := #[]) : IO Echo := do
  pendingCall.getPipelinedCap pointerPath
def callFooPipelinedM (pendingCall : Capnp.Rpc.RuntimePendingCallRef)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.Payload := do
  let target ← Capnp.Rpc.RuntimeM.pendingCallGetPipelinedCap pendingCall pointerPath
  Capnp.Rpc.RuntimeM.call target fooMethod payload
def callFooPipelinedTypedM (pendingCall : Capnp.Rpc.RuntimePendingCallRef)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM FooResponse := do
  let response ← callFooPipelinedM pendingCall pointerPath payload
  fooResponseOfPayload response
def FooPromise.getPipelinedCap (promise : FooPromise)
    (pointerPath : Array UInt16 := #[]) : IO Echo := do
  getFooPipelinedCap promise.pendingCall pointerPath
def FooPromise.callPipelinedM (promise : FooPromise)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.Payload := do
  callFooPipelinedM promise.pendingCall pointerPath payload
def FooPromise.callPipelinedTypedM (promise : FooPromise)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM FooResponse := do
  callFooPipelinedTypedM promise.pendingCall pointerPath payload

def barMethodId : UInt16 := UInt16.ofNat 1
def barMethod : Capnp.Rpc.Method := { interfaceId := interfaceId, methodId := barMethodId }
def callBar (backend : Capnp.Rpc.Backend) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO Capnp.Rpc.Payload := do
  Capnp.Rpc.call backend target barMethod payload
def callBarM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.Payload := do
  Capnp.Rpc.RuntimeM.call target barMethod payload
def startBar (runtime : Capnp.Rpc.Runtime) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO Capnp.Rpc.RuntimePendingCallRef := do
  Capnp.Rpc.Runtime.startCall runtime target barMethod payload
def startBarM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.RuntimePendingCallRef := do
  Capnp.Rpc.RuntimeM.startCall target barMethod payload
def awaitBar (pendingCall : Capnp.Rpc.RuntimePendingCallRef) : IO Capnp.Rpc.Payload := do
  pendingCall.await
abbrev BarResponse := Capnp.Rpc.TypedPayload Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.bar_Results.Reader
abbrev BarPromise := Capnp.Rpc.Promise BarResponse
def startBarPromise (runtime : Capnp.Rpc.Runtime) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO BarPromise := do
  return { pendingCall := (← startBar runtime target payload) }
def startBarPromiseM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM BarPromise := do
  return { pendingCall := (← startBarM target payload) }
def BarPromise.await (promise : BarPromise) : IO Capnp.Rpc.Payload := do
  awaitBar promise.pendingCall
def BarPromise.release (promise : BarPromise) : IO Unit :=
  promise.pendingCall.release
def BarPromise.releaseDeferred (promise : BarPromise) : IO Unit :=
  promise.pendingCall.releaseDeferred
abbrev barTypedHandler := Capnp.Rpc.Client -> Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.bar_Params.Reader -> Capnp.CapTable -> IO Capnp.Rpc.Payload
abbrev barAdvancedTypedHandler := Capnp.Rpc.Client -> Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.bar_Params.Reader -> Capnp.CapTable -> IO Capnp.Rpc.AdvancedHandlerReply
abbrev barStreamingTypedHandler := Capnp.Rpc.Client -> Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.bar_Params.Reader -> Capnp.CapTable -> IO Capnp.Rpc.AdvancedHandlerReply
def barRequestOfPayload (payload : Capnp.Rpc.Payload) : IO (Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.bar_Params.Reader × Capnp.CapTable) := do
  let reader ← match Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.bar_Params.readChecked (Capnp.getRoot payload.msg) with
    | Except.ok r => pure r
    | Except.error e => throw (IO.userError s!"invalid barMethod request: {e}")
  return (reader, payload.capTable)
def barResponseOfPayload (payload : Capnp.Rpc.Payload) : IO BarResponse := do
  let reader ← match Capnp.Gen.test.lean4.fixtures.rpc_echo.Echo.bar_Results.readChecked (Capnp.getRoot payload.msg) with
    | Except.ok r => pure r
    | Except.error e => throw (IO.userError s!"invalid barMethod response: {e}")
  return { reader := reader, capTable := payload.capTable }
def callBarTyped (backend : Capnp.Rpc.Backend) (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : IO BarResponse := do
  let response ← Capnp.Rpc.call backend target barMethod payload
  barResponseOfPayload response
def callBarTypedM (target : Echo) (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM BarResponse := do
  let response ← Capnp.Rpc.RuntimeM.call target barMethod payload
  barResponseOfPayload response
def awaitBarTyped (pendingCall : Capnp.Rpc.RuntimePendingCallRef) : IO BarResponse := do
  let response ← pendingCall.await
  barResponseOfPayload response
def BarPromise.awaitTyped (promise : BarPromise) : IO BarResponse := do
  awaitBarTyped promise.pendingCall
def BarPromise.awaitAndRelease (promise : BarPromise) : IO Capnp.Rpc.Payload := do
  promise.pendingCall.awaitAndRelease
def BarPromise.awaitTypedAndRelease (promise : BarPromise) : IO BarResponse := do
  let response ← promise.pendingCall.awaitAndRelease
  barResponseOfPayload response
def getBarPipelinedCap (pendingCall : Capnp.Rpc.RuntimePendingCallRef)
    (pointerPath : Array UInt16 := #[]) : IO Echo := do
  pendingCall.getPipelinedCap pointerPath
def callBarPipelinedM (pendingCall : Capnp.Rpc.RuntimePendingCallRef)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.Payload := do
  let target ← Capnp.Rpc.RuntimeM.pendingCallGetPipelinedCap pendingCall pointerPath
  Capnp.Rpc.RuntimeM.call target barMethod payload
def callBarPipelinedTypedM (pendingCall : Capnp.Rpc.RuntimePendingCallRef)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM BarResponse := do
  let response ← callBarPipelinedM pendingCall pointerPath payload
  barResponseOfPayload response
def BarPromise.getPipelinedCap (promise : BarPromise)
    (pointerPath : Array UInt16 := #[]) : IO Echo := do
  getBarPipelinedCap promise.pendingCall pointerPath
def BarPromise.callPipelinedM (promise : BarPromise)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Capnp.Rpc.Payload := do
  callBarPipelinedM promise.pendingCall pointerPath payload
def BarPromise.callPipelinedTypedM (promise : BarPromise)
    (pointerPath : Array UInt16 := #[])
    (payload : Capnp.Rpc.Payload := Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM BarResponse := do
  callBarPipelinedTypedM promise.pendingCall pointerPath payload

def restoreSturdyRef (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : IO Echo := do
  peer.restoreSturdyRef sturdyRef
def restoreSturdyRefM (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : Capnp.Rpc.RuntimeM Echo := do
  Capnp.Rpc.RuntimeM.multiVatRestoreSturdyRef peer sturdyRef
def restoreSturdyRefStart (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : IO Capnp.Rpc.RuntimeRegisterPromiseRef := do
  peer.restoreSturdyRefStart sturdyRef
def restoreSturdyRefStartM (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : Capnp.Rpc.RuntimeM Capnp.Rpc.RuntimeRegisterPromiseRef := do
  Capnp.Rpc.RuntimeM.multiVatRestoreSturdyRefStart peer sturdyRef
def awaitRestoreSturdyRef (promise : Capnp.Rpc.RuntimeRegisterPromiseRef) : IO Echo := do
  promise.awaitTarget
def awaitRestoreSturdyRefAndRelease (promise : Capnp.Rpc.RuntimeRegisterPromiseRef) : IO Echo := do
  promise.awaitTargetAndRelease
def restoreSturdyRefAsTask (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : IO (Task (Except IO.Error Echo)) := do
  peer.restoreSturdyRefAsTask sturdyRef
def restoreSturdyRefAsTaskM (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : Capnp.Rpc.RuntimeM (Task (Except IO.Error Echo)) := do
  Capnp.Rpc.RuntimeM.multiVatRestoreSturdyRefAsTask peer sturdyRef
def restoreSturdyRefAsPromise (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : IO (Capnp.Async.Promise Echo) := do
  peer.restoreSturdyRefAsPromise sturdyRef
def restoreSturdyRefAsPromiseM (peer : Capnp.Rpc.RuntimeVatPeerRef) (sturdyRef : Capnp.Rpc.SturdyRef) : Capnp.Rpc.RuntimeM (Capnp.Async.Promise Echo) := do
  Capnp.Rpc.RuntimeM.multiVatRestoreSturdyRefAsPromise peer sturdyRef

abbrev Handler := Capnp.Rpc.Handler
abbrev fooHandler := Handler
abbrev barHandler := Handler

structure Server where
  foo : fooHandler
  bar : barHandler

def dispatch (server : Server) : Capnp.Rpc.Dispatch := Id.run do
  let mut d := Capnp.Rpc.Dispatch.empty
  d := Capnp.Rpc.Dispatch.register d fooMethod server.foo
  d := Capnp.Rpc.Dispatch.register d barMethod server.bar
  return d

def backend (server : Server)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.Payload := fun _ _ _ => pure Capnp.emptyRpcEnvelope) : Capnp.Rpc.Backend where
  call := fun target method payload => do
    if method == fooMethod then
      server.foo target payload
    else if method == barMethod then
      server.bar target payload
    else
      onMissing target method payload

def registerTarget (runtime : Capnp.Rpc.Runtime) (server : Server)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.Payload := fun _ _ _ => pure Capnp.emptyRpcEnvelope) : IO Echo := do
  Capnp.Rpc.Runtime.registerBackendTarget runtime (backend server (onMissing := onMissing))

def registerTargetM (server : Server)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.Payload := fun _ _ _ => pure Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Echo := do
  Capnp.Rpc.RuntimeM.registerBackendTarget (backend server (onMissing := onMissing))

structure TypedServer where
  foo : fooTypedHandler
  bar : barTypedHandler

def typedDispatch (server : TypedServer) : Capnp.Rpc.Dispatch := Id.run do
  let mut d := Capnp.Rpc.Dispatch.empty
  d := Capnp.Rpc.Dispatch.register d fooMethod (fun target payload => do
    let (request, requestCaps) ← fooRequestOfPayload payload
    server.foo target request requestCaps
  )
  d := Capnp.Rpc.Dispatch.register d barMethod (fun target payload => do
    let (request, requestCaps) ← barRequestOfPayload payload
    server.bar target request requestCaps
  )
  return d

def typedBackend (server : TypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.Payload := fun _ _ _ => pure Capnp.emptyRpcEnvelope) : Capnp.Rpc.Backend where
  call := fun target method payload => do
    if method == fooMethod then do
      let (request, requestCaps) ← fooRequestOfPayload payload
      server.foo target request requestCaps
    else if method == barMethod then do
      let (request, requestCaps) ← barRequestOfPayload payload
      server.bar target request requestCaps
    else
      onMissing target method payload

def registerTypedTarget (runtime : Capnp.Rpc.Runtime) (server : TypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.Payload := fun _ _ _ => pure Capnp.emptyRpcEnvelope) : IO Echo := do
  Capnp.Rpc.Runtime.registerBackendTarget runtime (typedBackend server (onMissing := onMissing))

def registerTypedTargetM (server : TypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.Payload := fun _ _ _ => pure Capnp.emptyRpcEnvelope) : Capnp.Rpc.RuntimeM Echo := do
  Capnp.Rpc.RuntimeM.registerBackendTarget (typedBackend server (onMissing := onMissing))

structure AdvancedTypedServer where
  foo : fooAdvancedTypedHandler
  bar : barAdvancedTypedHandler

def advancedTypedTargetHandler (server : AdvancedTypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply := fun _ _ _ => pure (Capnp.Rpc.Advanced.now (Capnp.Rpc.Advanced.respond Capnp.emptyRpcEnvelope))) : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply :=
  fun target method payload => do
    if method == fooMethod then do
      let (request, requestCaps) ← fooRequestOfPayload payload
      server.foo target request requestCaps
    else if method == barMethod then do
      let (request, requestCaps) ← barRequestOfPayload payload
      server.bar target request requestCaps
    else
      onMissing target method payload

def registerAdvancedTypedTarget (runtime : Capnp.Rpc.Runtime) (server : AdvancedTypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply := fun _ _ _ => pure (Capnp.Rpc.Advanced.now (Capnp.Rpc.Advanced.respond Capnp.emptyRpcEnvelope))) : IO Echo := do
  Capnp.Rpc.Runtime.registerAdvancedHandlerTargetAsync runtime (advancedTypedTargetHandler server (onMissing := onMissing))

def registerAdvancedTypedTargetM (server : AdvancedTypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply := fun _ _ _ => pure (Capnp.Rpc.Advanced.now (Capnp.Rpc.Advanced.respond Capnp.emptyRpcEnvelope))) : Capnp.Rpc.RuntimeM Echo := do
  Capnp.Rpc.RuntimeM.registerAdvancedHandlerTargetAsync (advancedTypedTargetHandler server (onMissing := onMissing))

structure StreamingTypedServer where
  foo : fooStreamingTypedHandler
  bar : barStreamingTypedHandler

def streamingTypedTargetHandler (server : StreamingTypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply := fun _ _ _ => pure (Capnp.Rpc.Advanced.now (Capnp.Rpc.Advanced.respond Capnp.emptyRpcEnvelope))) : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply :=
  fun target method payload => do
    if method == fooMethod then do
      let (request, requestCaps) ← fooRequestOfPayload payload
      server.foo target request requestCaps
    else if method == barMethod then do
      let (request, requestCaps) ← barRequestOfPayload payload
      server.bar target request requestCaps
    else
      onMissing target method payload

def registerStreamingTypedTarget (runtime : Capnp.Rpc.Runtime) (server : StreamingTypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply := fun _ _ _ => pure (Capnp.Rpc.Advanced.now (Capnp.Rpc.Advanced.respond Capnp.emptyRpcEnvelope))) : IO Echo := do
  Capnp.Rpc.Runtime.registerStreamingHandlerTargetAsync runtime (streamingTypedTargetHandler server (onMissing := onMissing))

def registerStreamingTypedTargetM (server : StreamingTypedServer)
    (onMissing : Capnp.Rpc.Client -> Capnp.Rpc.Method -> Capnp.Rpc.Payload -> IO Capnp.Rpc.AdvancedHandlerReply := fun _ _ _ => pure (Capnp.Rpc.Advanced.now (Capnp.Rpc.Advanced.respond Capnp.emptyRpcEnvelope))) : Capnp.Rpc.RuntimeM Echo := do
  Capnp.Rpc.RuntimeM.registerStreamingHandlerTargetAsync (streamingTypedTargetHandler server (onMissing := onMissing))

end Echo

mutual
  structure Echo.foo_Params where
    payload : Capnp.AnyPointer


  structure Echo.foo_Results where
    payload : Capnp.AnyPointer


  structure Echo.bar_Params where
    payload : Capnp.AnyPointer


  structure Echo.bar_Results where
    payload : Capnp.AnyPointer


end


def Echo.foo_Params.Reader.getPayload (r : Echo.foo_Params.Reader) : Capnp.AnyPointer := Capnp.getPointer r.struct 0
def Echo.foo_Params.Reader.getPayloadChecked (r : Echo.foo_Params.Reader) : Except String (Capnp.AnyPointer) := Capnp.readAnyPointerChecked (Capnp.getPointer r.struct 0)
def Echo.foo_Params.Reader.hasPayload (r : Echo.foo_Params.Reader) : Bool := !Capnp.isNullPointer (Capnp.getPointer r.struct 0)

def Echo.foo_Params.initRoot : Capnp.BuilderM Echo.foo_Params.Builder := do
  let p ← Capnp.getRootPointer
  let sb ← Capnp.initStructPointer p 0 1
  return { struct := sb }

def Echo.foo_Params.Builder.clearPayload (b : Echo.foo_Params.Builder) : Capnp.BuilderM Unit := do
  Capnp.clearPointer (Capnp.getPointerBuilder b.struct 0)

def Echo.foo_Params.Builder.getPayload (b : Echo.foo_Params.Builder) : Capnp.AnyPointerBuilder := Capnp.getPointerBuilder b.struct 0


def Echo.foo_Results.Reader.getPayload (r : Echo.foo_Results.Reader) : Capnp.AnyPointer := Capnp.getPointer r.struct 0
def Echo.foo_Results.Reader.getPayloadChecked (r : Echo.foo_Results.Reader) : Except String (Capnp.AnyPointer) := Capnp.readAnyPointerChecked (Capnp.getPointer r.struct 0)
def Echo.foo_Results.Reader.hasPayload (r : Echo.foo_Results.Reader) : Bool := !Capnp.isNullPointer (Capnp.getPointer r.struct 0)

def Echo.foo_Results.initRoot : Capnp.BuilderM Echo.foo_Results.Builder := do
  let p ← Capnp.getRootPointer
  let sb ← Capnp.initStructPointer p 0 1
  return { struct := sb }

def Echo.foo_Results.Builder.clearPayload (b : Echo.foo_Results.Builder) : Capnp.BuilderM Unit := do
  Capnp.clearPointer (Capnp.getPointerBuilder b.struct 0)

def Echo.foo_Results.Builder.getPayload (b : Echo.foo_Results.Builder) : Capnp.AnyPointerBuilder := Capnp.getPointerBuilder b.struct 0


def Echo.bar_Params.Reader.getPayload (r : Echo.bar_Params.Reader) : Capnp.AnyPointer := Capnp.getPointer r.struct 0
def Echo.bar_Params.Reader.getPayloadChecked (r : Echo.bar_Params.Reader) : Except String (Capnp.AnyPointer) := Capnp.readAnyPointerChecked (Capnp.getPointer r.struct 0)
def Echo.bar_Params.Reader.hasPayload (r : Echo.bar_Params.Reader) : Bool := !Capnp.isNullPointer (Capnp.getPointer r.struct 0)

def Echo.bar_Params.initRoot : Capnp.BuilderM Echo.bar_Params.Builder := do
  let p ← Capnp.getRootPointer
  let sb ← Capnp.initStructPointer p 0 1
  return { struct := sb }

def Echo.bar_Params.Builder.clearPayload (b : Echo.bar_Params.Builder) : Capnp.BuilderM Unit := do
  Capnp.clearPointer (Capnp.getPointerBuilder b.struct 0)

def Echo.bar_Params.Builder.getPayload (b : Echo.bar_Params.Builder) : Capnp.AnyPointerBuilder := Capnp.getPointerBuilder b.struct 0


def Echo.bar_Results.Reader.getPayload (r : Echo.bar_Results.Reader) : Capnp.AnyPointer := Capnp.getPointer r.struct 0
def Echo.bar_Results.Reader.getPayloadChecked (r : Echo.bar_Results.Reader) : Except String (Capnp.AnyPointer) := Capnp.readAnyPointerChecked (Capnp.getPointer r.struct 0)
def Echo.bar_Results.Reader.hasPayload (r : Echo.bar_Results.Reader) : Bool := !Capnp.isNullPointer (Capnp.getPointer r.struct 0)

def Echo.bar_Results.initRoot : Capnp.BuilderM Echo.bar_Results.Builder := do
  let p ← Capnp.getRootPointer
  let sb ← Capnp.initStructPointer p 0 1
  return { struct := sb }

def Echo.bar_Results.Builder.clearPayload (b : Echo.bar_Results.Builder) : Capnp.BuilderM Unit := do
  Capnp.clearPointer (Capnp.getPointerBuilder b.struct 0)

def Echo.bar_Results.Builder.getPayload (b : Echo.bar_Results.Builder) : Capnp.AnyPointerBuilder := Capnp.getPointerBuilder b.struct 0


mutual
  def Echo.foo_Params.Builder.setFromValue (b : Echo.foo_Params.Builder) (v : Echo.foo_Params) : Capnp.BuilderM Unit := do
    Capnp.copyAnyPointer (Capnp.getPointerBuilder b.struct 0) v.payload


  def Echo.foo_Results.Builder.setFromValue (b : Echo.foo_Results.Builder) (v : Echo.foo_Results) : Capnp.BuilderM Unit := do
    Capnp.copyAnyPointer (Capnp.getPointerBuilder b.struct 0) v.payload


  def Echo.bar_Params.Builder.setFromValue (b : Echo.bar_Params.Builder) (v : Echo.bar_Params) : Capnp.BuilderM Unit := do
    Capnp.copyAnyPointer (Capnp.getPointerBuilder b.struct 0) v.payload


  def Echo.bar_Results.Builder.setFromValue (b : Echo.bar_Results.Builder) (v : Echo.bar_Results) : Capnp.BuilderM Unit := do
    Capnp.copyAnyPointer (Capnp.getPointerBuilder b.struct 0) v.payload


end


mutual
  def Echo.foo_Params.ofReader (r : Echo.foo_Params.Reader) : Echo.foo_Params :=
    { payload := r.getPayload
    }


  def Echo.foo_Results.ofReader (r : Echo.foo_Results.Reader) : Echo.foo_Results :=
    { payload := r.getPayload
    }


  def Echo.bar_Params.ofReader (r : Echo.bar_Params.Reader) : Echo.bar_Params :=
    { payload := r.getPayload
    }


  def Echo.bar_Results.ofReader (r : Echo.bar_Results.Reader) : Echo.bar_Results :=
    { payload := r.getPayload
    }


end

end Capnp.Gen.test.lean4.fixtures.rpc_echo
